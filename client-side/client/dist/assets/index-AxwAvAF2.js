var fe=Object.defineProperty;var he=(n,r,e)=>r in n?fe(n,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[r]=e;var I=(n,r,e)=>(he(n,typeof r!="symbol"?r+"":r,e),e);import{a as te,aY as pe,bD as d,bE as Z,b9 as de,aN as z,bF as P,aM as $,ax as R,bG as D,bH as re,_ as me,ae as ye,B as O,bz as J,aj as k,ar as se,as as ge,at as be,aw as q,aL as S,aO as X,bI as we,bc as Q,bJ as Se,ba as _,av as xe,bK as W,bL as Te,bM as F,bN as Pe,bO as K,bP as Be}from"./index-OE56k1X-.js";import{S as ne,E as Ie}from"./assertEnabled-bf987093.browser.esm-P_KwqYUb.js";import{N as j}from"./setErc20Allowance-f181219a.browser.esm-6VTEKsm9.js";var Ae=function(r){for(var e=new Buffer(r.length),t=0,s=r.length-1;t<=s;++t,--s)e[t]=r[s],e[s]=r[t];return e};const v=te(Ae);var ae={exports:{}};(function(n,r){(function(e,t){n.exports=t()})(pe,function(){function e(o,u){var i=u?"└":"├";return o?i+="─ ":i+="──┐",i}function t(o,u){var i=[];for(var l in o)o.hasOwnProperty(l)&&(u&&typeof o[l]=="function"||i.push(l));return i}function s(o,u,i,l,c,h,f){var p="",m=0,x,y,g=l.slice(0);if(g.push([u,i])&&l.length>0&&(l.forEach(function(b,T){T>0&&(p+=(b[1]?" ":"│")+"  "),!y&&b[0]===u&&(y=!0)}),p+=e(o,i)+o,c&&(typeof u!="object"||u instanceof Date)&&(p+=": "+u),y&&(p+=" (circular ref.)"),f(p)),!y&&typeof u=="object"){var B=t(u,h);B.forEach(function(b){x=++m===B.length,s(b,u[b],x,g,c,h,f)})}}var a={};return a.asLines=function(o,u,i,l){var c=typeof i!="function"?i:!1;s(".",o,!1,[],u,c,l||i)},a.asTree=function(o,u,i){var l="";return s(".",o,!1,[],u,i,function(c){l+=c+`
`}),l},a})})(ae);var Ce=ae.exports;class C{print(){C.print(this)}bufferIndexOf(r,e){if(arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1)return this.binarySearch(r,e,d.Buffer.compare);const s=(a,o)=>a.equals(o);return this.linearSearch(r,e,s)}static binarySearch(r,e,t){let s=0,a=r.length-1;for(;s<=a;){const o=Math.floor((s+a)/2),u=t(r[o],e);if(u===0){for(let i=o-1;i>=0;i--)if(t(r[i],e)!==0)return i+1;return 0}else u<0?s=o+1:a=o-1}return-1}binarySearch(r,e,t){return C.binarySearch(r,e,t)}static linearSearch(r,e,t){for(let s=0;s<r.length;s++)if(t(r[s],e))return s;return-1}linearSearch(r,e,t){return C.linearSearch(r,e,t)}static bufferify(r){if(!d.Buffer.isBuffer(r)){if(typeof r=="object"&&r.words)return d.Buffer.from(r.toString(ke),"hex");if(C.isHexString(r))return d.Buffer.from(r.replace(/^0x/,""),"hex");if(typeof r=="string")return d.Buffer.from(r);if(typeof r=="bigint")return d.Buffer.from(r.toString(16),"hex");if(r instanceof Uint8Array)return d.Buffer.from(r.buffer);if(typeof r=="number"){let e=r.toString();return e.length%2&&(e=`0${e}`),d.Buffer.from(e,"hex")}else if(ArrayBuffer.isView(r))return d.Buffer.from(r.buffer,r.byteOffset,r.byteLength)}return r}bigNumberify(r){return C.bigNumberify(r)}static bigNumberify(r){if(typeof r=="bigint")return r;if(typeof r=="string")return r.startsWith("0x")&&C.isHexString(r)?BigInt("0x"+r.replace("0x","").toString()):BigInt(r);if(d.Buffer.isBuffer(r))return BigInt("0x"+r.toString("hex"));if(r instanceof Uint8Array)return He(r);if(typeof r=="number")return BigInt(r);throw new Error("cannot bigNumberify")}static isHexString(r){return typeof r=="string"&&/^(0x)?[0-9A-Fa-f]*$/.test(r)}static print(r){console.log(r.toString())}bufferToHex(r){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return C.bufferToHex(r,e)}static bufferToHex(r){return`${(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0)?"0x":""}${(r||d.Buffer.alloc(0)).toString("hex")}`}bufferify(r){return C.bufferify(r)}bufferifyFn(r){return e=>{const t=r(e);if(d.Buffer.isBuffer(t))return t;if(this.isHexString(t))return d.Buffer.from(t.replace("0x",""),"hex");if(typeof t=="string")return d.Buffer.from(t);if(typeof t=="bigint")return d.Buffer.from(e.toString(16),"hex");if(ArrayBuffer.isView(t))return d.Buffer.from(t.buffer,t.byteOffset,t.byteLength);const s=Oe(e.toString("hex")),a=r(s),o=Le(a);return d.Buffer.from(o,"hex")}}isHexString(r){return C.isHexString(r)}log2(r){return r===1?0:1+this.log2(r/2|0)}zip(r,e){return r.map((t,s)=>[t,e[s]])}static hexZeroPad(r,e){return"0x"+r.replace("0x","").padStart(e,"0")}}var ve=C;function ke(n){const r=n.words,e=new ArrayBuffer(r.length*4),t=new Uint8Array(e);for(let s=0;s<r.length;s++)t[s*4]=r[s]>>24&255,t[s*4+1]=r[s]>>16&255,t[s*4+2]=r[s]>>8&255,t[s*4+3]=r[s]&255;return e}function Oe(n){const r=new Uint8Array(n.length/2);for(let e=0;e<n.length;e+=2)r[e/2]=parseInt(n.substring(e,e+2),16);return r.buffer}function Le(n){const r=new Uint8Array(n);return Array.from(r).map(e=>e.toString(16).padStart(2,"0")).join("")}function He(n){const r=Array.from(n).map(e=>e.toString(16).padStart(2,"0")).join("");return BigInt(`0x${r}`)}class L extends ve{constructor(e,t){let s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};super();I(this,"duplicateOdd",!1);I(this,"concatenator",d.Buffer.concat);I(this,"hashLeaves",!1);I(this,"isBitcoinTree",!1);I(this,"leaves",[]);I(this,"layers",[]);I(this,"sortLeaves",!1);I(this,"sortPairs",!1);I(this,"sort",!1);I(this,"fillDefaultHash",null);I(this,"complete",!1);if(s.complete){if(s.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(s.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!s.isBitcoinTree,this.hashLeaves=!!s.hashLeaves,this.sortLeaves=!!s.sortLeaves,this.sortPairs=!!s.sortPairs,this.complete=!!s.complete,s.fillDefaultHash)if(typeof s.fillDefaultHash=="function")this.fillDefaultHash=s.fillDefaultHash;else if(d.Buffer.isBuffer(s.fillDefaultHash)||typeof s.fillDefaultHash=="string")this.fillDefaultHash=(a,o)=>s.fillDefaultHash;else throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.sort=!!s.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!s.duplicateOdd,s.concatenator&&(this.concatenator=s.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){var e;return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:((e=this.fillDefaultHash)==null?void 0:e.toString())??null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(d.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const s=this.complete&&t===1&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let a=0;a<e.length;a+=2){if(a>=s){this.layers[t].push(...e.slice(s));break}else if(a+1===e.length&&e.length%2===1){const c=e[e.length-1];let h=c;if(this.isBitcoinTree){h=this.hashFn(this.concatenator([v(c),v(c)])),h=v(this.hashFn(h)),this.layers[t].push(h);continue}else if(!this.duplicateOdd){this.layers[t].push(e[a]);continue}}const o=e[a],u=a+1===e.length?o:e[a+1];let i=null;this.isBitcoinTree?i=[v(o),v(u)]:i=[o,u],this.sortPairs&&i.sort(d.Buffer.compare);let l=this.hashFn(this.concatenator(i));this.isBitcoinTree&&(l=v(this.hashFn(l))),this.layers[t].push(l)}e=this.layers[t]}}addLeaf(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(d.Buffer.compare))),this.leaves.filter(t=>this.bufferIndexOf(e,t,this.sortLeaves)!==-1)):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?d.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let s=0;s<t.length;s++)if(t[s].equals(e))return s;return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(t=>L.bufferToHex(t)),null,2)}static unmarshalLeaves(e){let t=null;if(typeof e=="string")t=JSON.parse(e);else if(e instanceof Object)t=e;else throw new Error("Expected type of string or object");if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(L.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(s=>this.bufferToHex(s))):e.push(t),e),[])}getLayersFlat(){const e=this.layers.reduce((t,s)=>(Array.isArray(s)?t.unshift(...s):t.unshift(s),t),[]);return e.unshift(d.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return this.layers.length===0?d.Buffer.from([]):this.layers[this.layers.length-1][0]||d.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(typeof e>"u")throw new Error("leaf is required");e=this.bufferify(e);const s=[];if(!Number.isInteger(t)){t=-1;for(let a=0;a<this.leaves.length;a++)d.Buffer.compare(e,this.leaves[a])===0&&(t=a)}if(t<=-1)return[];for(let a=0;a<this.layers.length;a++){const o=this.layers[a],u=t%2,i=u?t-1:this.isBitcoinTree&&t===o.length-1&&a<this.layers.length-1?t:t+1;i<o.length&&s.push({position:u?"left":"right",data:o[i]}),t=t/2|0}return s}getHexProof(e,t){return this.getProof(e,t).map(s=>this.bufferToHex(s.data))}getProofs(){const e=[],t=[];return this.getProofsDFS(this.layers.length-1,0,e,t),t}getProofsDFS(e,t,s,a){const o=t%2;if(e===-1){o||a.push([...s].reverse());return}if(t>=this.layers[e].length)return;const u=this.layers[e],i=o?t-1:t+1;let l=!1;i<u.length&&(l=!0,s.push({position:o?"left":"right",data:u[i]}));const c=t*2,h=t*2+1;this.getProofsDFS(e-1,c,s,a),this.getProofsDFS(e-1,h,s,a),l&&s.splice(s.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(s=>[s.position==="left"?0:1,this.bufferToHex(s.data)])}getProofIndices(e,t){const s=2**t;let a=new Set;for(const c of e){let h=s+c;for(;h>1;)a.add(h^1),h=h/2|0}const o=e.map(c=>s+c),u=Array.from(a).sort((c,h)=>c-h).reverse();a=o.concat(u);const i=new Set,l=[];for(let c of a)if(!i.has(c))for(l.push(c);c>1&&(i.add(c),!!i.has(c^1));)c=c/2|0;return l.filter(c=>!e.includes(c-s))}getProofIndicesForUnevenTree(e,t){const s=Math.ceil(Math.log2(t)),a=[];for(let i=0;i<s;i++)t%2!==0&&a.push({index:i,leavesCount:t}),t=Math.ceil(t/2);const o=[];let u=e;for(let i=0;i<s;i++){let c=u.map(f=>f%2===0?f+1:f-1).filter(f=>!u.includes(f));const h=a.find(f=>{let{index:p}=f;return p===i});h&&u.includes(h.leavesCount-1)&&(c=c.slice(0,-1)),o.push(c),u=[...new Set(u.map(f=>f%2===0?f/2:f%2===0?(f+1)/2:(f-1)/2))]}return o}getMultiProof(e,t){if(this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat()),this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let a=t;this.sortPairs&&(a=a.sort(d.Buffer.compare));let o=a.map(c=>this.bufferIndexOf(this.leaves,c,this.sortLeaves)).sort((c,h)=>c===h?0:c>h?1:-1);if(!o.every(c=>c!==-1))throw new Error("Element does not exist in Merkle tree");const u=[],i=[];let l=[];for(let c=0;c<this.layers.length;c++){const h=this.layers[c];for(let f=0;f<o.length;f++){const p=o[f],m=this.getPairNode(h,p);u.push(h[p]),m&&i.push(m),l.push(p/2|0)}o=l.filter((f,p,m)=>m.indexOf(f)===p),l=[]}return i.filter(c=>!u.includes(c))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(a=>e[a])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let s=[],a=t;for(const o of e){const u=[];for(const l of a){if(l%2===0){const h=l+1;if(!a.includes(h)&&o[h]){u.push(o[h]);continue}}const c=l-1;if(!a.includes(c)&&o[c]){u.push(o[c]);continue}}s=s.concat(u);const i=new Set;for(const l of a){if(l%2===0){i.add(l/2);continue}if(l%2===0){i.add((l+1)/2);continue}i.add((l-1)/2)}a=Array.from(i)}return s}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(s=>this.bufferToHex(s))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let s;if(e.every(Number.isInteger)?s=[...e].sort((i,l)=>i===l?0:i>l?1:-1):s=e.map(i=>this.bufferIndexOf(this.leaves,i,this.sortLeaves)).sort((i,l)=>i===l?0:i>l?1:-1),!s.every(i=>i!==-1))throw new Error("Element does not exist in Merkle tree");const a=t.map(i=>this.bufferify(i)),o=[],u=[];for(let i=0;i<this.layers.length;i++){const l=this.layers[i];s=s.reduce((c,h)=>{if(!o.includes(l[h])){const p=this.getPairNode(l,h),m=a.includes(l[h])||a.includes(p);p&&u.push(!m),o.push(l[h]),o.push(p)}return c.push(h/2|0),c},[])}return u}verify(e,t,s){let a=this.bufferify(t);if(s=this.bufferify(s),!Array.isArray(e)||!t||!s)return!1;for(let o=0;o<e.length;o++){const u=e[o];let i=null,l=null;if(typeof u=="string")i=this.bufferify(u),l=!0;else if(Array.isArray(u))l=u[0]===0,i=this.bufferify(u[1]);else if(d.Buffer.isBuffer(u))i=u,l=!0;else if(u instanceof Object)i=this.bufferify(u.data),l=u.position==="left";else throw new Error("Expected node to be of type string or object");const c=[];this.isBitcoinTree?(c.push(v(a)),c[l?"unshift":"push"](v(i)),a=this.hashFn(this.concatenator(c)),a=v(this.hashFn(a))):this.sortPairs?d.Buffer.compare(a,i)===-1?(c.push(a,i),a=this.hashFn(this.concatenator(c))):(c.push(i,a),a=this.hashFn(this.concatenator(c))):(c.push(a),c[l?"unshift":"push"](i),a=this.hashFn(this.concatenator(c)))}return d.Buffer.compare(a,s)===0}verifyMultiProof(e,t,s,a,o){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,s,a,o);const i=Math.ceil(Math.log2(a));e=this.bufferify(e),s=s.map(f=>this.bufferify(f)),o=o.map(f=>this.bufferify(f));const l={};for(const[f,p]of this.zip(t,s))l[2**i+f]=p;for(const[f,p]of this.zip(this.getProofIndices(t,i),o))l[f]=p;let c=Object.keys(l).map(f=>Number(f)).sort((f,p)=>f-p);c=c.slice(0,c.length-1);let h=0;for(;h<c.length;){const f=c[h];if(f>=2&&{}.hasOwnProperty.call(l,f^1)){let p=[l[f-f%2],l[f-f%2+1]];this.sortPairs&&(p=p.sort(d.Buffer.compare));const m=p[1]?this.hashFn(this.concatenator(p)):p[0];l[f/2|0]=m,c.push(f/2|0)}h+=1}return!t.length||{}.hasOwnProperty.call(l,1)&&l[1].equals(e)}verifyMultiProofWithFlags(e,t,s,a){e=this.bufferify(e),t=t.map(this.bufferify),s=s.map(this.bufferify);const o=t.length,u=a.length,i=[];let l=0,c=0,h=0;for(let f=0;f<u;f++){const p=a[f]?l<o?t[l++]:i[c++]:s[h++],m=l<o?t[l++]:i[c++],x=[p,m].sort(d.Buffer.compare);i[f]=this.hashFn(this.concatenator(x))}return d.Buffer.compare(i[u-1],e)===0}verifyMultiProofForUnevenTree(e,t,s,a,o){e=this.bufferify(e),s=s.map(i=>this.bufferify(i)),o=o.map(i=>this.bufferify(i));const u=this.calculateRootForUnevenTree(t,s,a,o);return e.equals(u)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map(s=>s.map(a=>this.bufferToHex(a,!1))),t=[];for(let s=0;s<e.length;s++){const a=[];for(let o=0;o<e[s].length;o++){const u={[e[s][o]]:null};if(t.length){u[e[s][o]]={};const i=t.shift(),l=Object.keys(i)[0];if(u[e[s][o]][l]=i[l],t.length){const c=t.shift(),h=Object.keys(c)[0];u[e[s][o]][h]=c[h]}}a.push(u)}t.push(...a)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const s=t%2===0?t+1:t-1;return s<e.length?e[s]:null}toTreeString(){const e=this.getLayersAsObject();return Ce.asTree(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){const t=(e==null?void 0:e.length)||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,s,a){const o=this.zip(e,t).sort((f,p)=>{let[m]=f,[x]=p;return m-x}),u=o.map(f=>{let[p]=f;return p}),i=this.getProofIndicesForUnevenTree(u,s);let l=0;const c=[];for(let f=0;f<i.length;f++){const p=i[f],m=l;l+=p.length,c[f]=this.zip(p,a.slice(m,l))}const h=[o];for(let f=0;f<c.length;f++){const p=c[f].concat(h[f]).sort((g,B)=>{let[b]=g,[T]=B;return b-T}).map(g=>{let[,B]=g;return B}),m=h[f].map(g=>{let[B]=g;return B}),x=[...new Set(m.map(g=>g%2===0?g/2:g%2===0?(g+1)/2:(g-1)/2))],y=[];for(let g=0;g<x.length;g++){const B=x[g],b=p[g*2],T=p[g*2+1],N=T?this.hashFn(this.concatenator([b,T])):b;y.push([B,N])}h.push(y)}return h[h.length-1][0][1]}}let E;const Ne=new Uint8Array(16);function Re(){if(!E&&(E=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!E))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return E(Ne)}const w=[];for(let n=0;n<256;++n)w.push((n+256).toString(16).slice(1));function Ue(n,r=0){return w[n[r+0]]+w[n[r+1]]+w[n[r+2]]+w[n[r+3]]+"-"+w[n[r+4]]+w[n[r+5]]+"-"+w[n[r+6]]+w[n[r+7]]+"-"+w[n[r+8]]+w[n[r+9]]+"-"+w[n[r+10]]+w[n[r+11]]+w[n[r+12]]+w[n[r+13]]+w[n[r+14]]+w[n[r+15]]}const Ee=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),ee={randomUUID:Ee};function Me(n,r,e){if(ee.randomUUID&&!r&&!n)return ee.randomUUID();n=n||{};const t=n.random||(n.rng||Re)();if(t[6]=t[6]&15|64,t[8]=t[8]&63|128,r){e=e||0;for(let s=0;s<16;++s)r[e+s]=t[s];return r}return Ue(t)}function nt(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot,pricePerToken:n.pricePerToken,currency:n.currency,quantityLimitPerTransaction:n.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:n.waitTimeInSecondsBetweenClaims||0}}function at(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot,pricePerToken:n.pricePerToken,currency:n.currency,quantityLimitPerWallet:n.maxClaimablePerWallet,metadata:n.metadata||""}}function H(n,r){return n==="unlimited"?R:D(n,r)}async function ie(n){const e=Array.from({length:Math.ceil(n.length/25e3)},(a,o)=>n.slice(o*25e3,o*25e3+25e3)),t=[],s=await Promise.all(e.map(a=>K.parseAsync(a)));for(const a of s)t.push(...a);return t}const De=2;let V=function(n){return n[n.V1=1]="V1",n[n.V2=2]="V2",n}({});class A{constructor(r,e,t,s,a){this.storage=r,this.shardNybbles=s,this.baseUri=e,this.originalEntriesUri=t,this.tokenDecimals=a,this.shards={},this.trees={}}static async fromUri(r,e){try{const t=await e.downloadJSON(r);if(t.isShardedMerkleTree)return A.fromShardedMerkleTreeInfo(t,e)}catch{return}}static async fromShardedMerkleTreeInfo(r,e){return new A(e,r.baseUri,r.originalEntriesUri,r.shardNybbles,r.tokenDecimals)}static hashEntry(r,e,t,s){switch(s){case V.V1:return _(["address","uint256"],[r.address,H(r.maxClaimable,e)]);case V.V2:return _(["address","uint256","uint256","address"],[r.address,H(r.maxClaimable,e),H(r.price||"unlimited",t),r.currencyAddress||k])}}static async fetchAndCacheDecimals(r,e,t){if(!t)return 18;let s=r[t];return s===void 0&&(s=(await xe(e,t)).decimals,r[t]=s),s}static async buildAndUpload(r,e,t,s,a){let o=arguments.length>5&&arguments[5]!==void 0?arguments[5]:De;const u=await ie(r),i={};for(const b of u){const T=b.address.slice(2,2+o).toLowerCase();i[T]===void 0&&(i[T]=[]),i[T].push(b)}const l={},c=await Promise.all(Object.entries(i).map(async b=>{let[T,N]=b;return[T,new L(await Promise.all(N.map(async U=>{const ce=await A.fetchAndCacheDecimals(l,t,U.currencyAddress);return A.hashEntry(U,e,ce,a)})),W,{sort:!0}).getHexRoot()]})),h=Object.fromEntries(c),f=new L(Object.values(h),W,{sort:!0}),p=[];for(const[b,T]of Object.entries(i)){const N={proofs:f.getProof(h[b]).map(U=>"0x"+U.data.toString("hex")),entries:T};p.push({data:JSON.stringify(N),name:`${b}.json`})}const m=await s.uploadBatch(p),x=m[0].slice(0,m[0].lastIndexOf("/")),y=await s.upload(u),g={merkleRoot:f.getHexRoot(),baseUri:x,originalEntriesUri:y,shardNybbles:o,tokenDecimals:e,isShardedMerkleTree:!0},B=await s.upload(g);return{shardedMerkleInfo:g,uri:B}}async getProof(r,e,t){const s=r.slice(2,2+this.shardNybbles).toLowerCase();let a=this.shards[s];const o={};if(a===void 0)try{const h=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;a=this.shards[s]=await this.storage.downloadJSON(`${h}${s}.json`);const f=await Promise.all(a.entries.map(async p=>{const m=await A.fetchAndCacheDecimals(o,e,p.currencyAddress);return A.hashEntry(p,this.tokenDecimals,m,t)}));this.trees[s]=new L(f,W,{sort:!0})}catch{return null}const u=a.entries.find(h=>h.address.toLowerCase()===r.toLowerCase());if(!u)return null;const i=await A.fetchAndCacheDecimals(o,e,u.currencyAddress),l=A.hashEntry(u,this.tokenDecimals,i,t),c=this.trees[s].getProof(l).map(h=>"0x"+h.data.toString("hex"));return Te.parseAsync({...u,proof:c.concat(a.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(r){return console.warn("Could not fetch original snapshot entries",r),[]}}}async function Fe(n,r,e,t,s,a){if(!e)return null;const o=e[r];if(o){const u=await s.downloadJSON(o);if(u.isShardedMerkleTree&&u.merkleRoot===r)return await(await A.fromShardedMerkleTreeInfo(u,s)).getProof(n,t,a);const i=await re.parseAsync(u);if(r===i.merkleRoot)return i.claims.find(l=>l.address.toLowerCase()===n.toLowerCase())||null}return null}function it(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot.toString(),pricePerToken:n.pricePerToken,currency:n.currency,maxClaimablePerWallet:n.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:n.waitTimeInSecondsBetweenClaims}}function ot(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot.toString(),pricePerToken:n.pricePerToken,currency:n.currency,maxClaimablePerWallet:n.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:n.metadata}}async function je(n,r,e,t,s){const a=n.getSigner(),o=n.getProvider(),u=(await me(()=>import("./index-OE56k1X-.js").then(p=>p.eu),__vite__mapDeps([0,1]))).default,i=new ye(a||o,r,u,n.options,n.storage),l=await n.getSignerAddress(),c=n.address,h=await i.read("allowance",[l,c]),f=O.from(e).mul(O.from(t)).div(D("1",s));h.lt(f)&&await i.sendTransaction("approve",[c,h.add(f)])}async function ut(n,r,e,t,s,a,o,u,i){let l=H(e.maxClaimablePerWallet,s),c=[J([0],32)],h=e.price,f=e.currencyAddress;try{if(!e.merkleRootHash.toString().startsWith(k)){const y=await Fe(n,e.merkleRootHash.toString(),await t(),a.getProvider(),o,i);if(y)c=y.proof,l=y.maxClaimable==="unlimited"?R:D(y.maxClaimable,s),h=y.price===void 0||y.price==="unlimited"?R:await se(a.getProvider(),y.price,y.currencyAddress||k),f=y.currencyAddress||k;else if(i===V.V1)throw new Error("No claim found for this address")}}catch(y){if((y==null?void 0:y.message)==="No claim found for this address")throw y;console.warn("failed to check claim condition merkle root hash, continuing anyways",y)}const p=await a.getCallOverrides()||{},m=h.toString()!==R.toString()?h:e.price,x=f!==k?f:e.currencyAddress;return m.gt(0)&&(ge(x)?p.value=O.from(m).mul(r).div(D("1",s)):u&&await je(a,x,m,r,s)),{overrides:p,proofs:c,maxClaimable:l,price:m,currencyAddress:x,priceInProof:h,currencyAddressInProof:f}}const We=S.object({name:S.string(),symbol:S.string(),decimals:S.number()}),qe=We.extend({value:P,displayValue:S.string()}),Ve=S.object({name:S.string().optional()}).catchall(S.unknown()),G=S.object({startTime:ne,currencyAddress:S.string().default(Q),price:z.default(0),maxClaimableSupply:F,maxClaimablePerWallet:F,waitInSeconds:$.default(0),merkleRootHash:Pe.default(J([0],32)),snapshot:S.optional(K).nullable(),metadata:Ve.optional()}),ze=S.array(G),oe=G.extend({availableSupply:F,currentMintSupply:F,currencyMetadata:qe.default({value:O.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:P,waitInSeconds:P,startTime:P.transform(n=>new Date(n.toNumber()*1e3)),snapshot:K.optional().nullable()});async function $e(n,r,e,t,s){const a=await ie(n),o=a.map(l=>l.address);if(new Set(o).size<o.length)throw new Be;const i=await A.buildAndUpload(a,r,e,t,s);return{merkleRoot:i.shardedMerkleInfo.merkleRoot,snapshotUri:i.uri}}function Je(n,r){const e=O.from(n),t=O.from(r);return e.eq(t)?0:e.gt(t)?1:-1}async function Qe(n,r,e,t,s){const a=[];return{inputsWithSnapshots:await Promise.all(n.map(async u=>{if(u.snapshot&&u.snapshot.length>0){const i=await $e(u.snapshot,r,e,t,s);a.push(i),u.merkleRootHash=i.merkleRoot}else u.merkleRootHash=J([0],32);return u})),snapshotInfos:a}}async function Ke(n,r,e,t){const s=n.currencyAddress===k?Q:n.currencyAddress,a=H(n.maxClaimableSupply,r),o=H(n.maxClaimablePerWallet,r);let u;return n.metadata&&(typeof n.metadata=="string"?u=n.metadata:u=await t.upload(n.metadata)),{startTimestamp:n.startTime,maxClaimableSupply:a,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await se(e,n.price,s),currency:s,merkleRoot:n.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:n.waitInSeconds||0,metadata:u}}async function lt(n,r,e,t,s){const{inputsWithSnapshots:a,snapshotInfos:o}=await Qe(n,r,e,t,s),u=await ze.parseAsync(a),i=(await Promise.all(u.map(l=>Ke(l,r,e,t)))).sort((l,c)=>Je(l.startTimestamp,c.startTimestamp));return{snapshotInfos:o,sortedConditions:i}}async function Ge(n,r,e){if(!r)return null;const t=r[n];if(t){const s=await e.downloadJSON(t);if(s.isShardedMerkleTree&&s.merkleRoot===n){const a=await A.fromUri(t,e);return(a==null?void 0:a.getAllEntries())||null}else{const a=await re.parseAsync(s);if(n===a.merkleRoot)return a.claims.map(o=>({address:o.address,maxClaimable:o.maxClaimable,price:o.price,currencyAddress:o.currencyAddress}))}}return null}function M(n,r){return n.toString()===R.toString()?"unlimited":q(n,r)}async function ct(n,r,e,t,s,a){var f;const o=await be(e,n.currency,n.pricePerToken),u=M(n.maxClaimableSupply,r),i=M(n.maxClaimablePerWallet,r),l=M(O.from(n.maxClaimableSupply).sub(n.supplyClaimed),r),c=M(n.supplyClaimed,r);let h;return n.metadata&&(h=await s.downloadJSON(n.metadata)),oe.parseAsync({startTime:n.startTimestamp,maxClaimableSupply:u,maxClaimablePerWallet:i,currentMintSupply:c,availableSupply:l,waitInSeconds:(f=n.waitTimeInSecondsBetweenClaims)==null?void 0:f.toString(),price:O.from(n.pricePerToken),currency:n.currency,currencyAddress:n.currency,currencyMetadata:o,merkleRootHash:n.merkleRoot,snapshot:a?await Ge(n.merkleRoot,t,s):void 0,metadata:h})}async function ft(n,r,e){if(n>=e.length)throw Error(`Index out of bounds - got index: ${n} with ${e.length} conditions`);const t=e[n].currencyMetadata.decimals,s=e[n].price,a=q(s,t),o=await G.parseAsync({...e[n],price:a,...r}),u=await oe.parseAsync({...o,price:s});return e.map((i,l)=>{let c;l===n?c=u:c=i;const h=q(c.price,t);return{...c,price:h}})}let ht=function(n){return n.NotEnoughSupply="There is not enough supply to claim.",n.AddressNotAllowed="This address is not on the allowlist.",n.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",n.ClaimPhaseNotStarted="Claim phase has not started yet.",n.AlreadyClaimed="You have already claimed the token.",n.WrongPriceOrCurrency="Incorrect price or currency.",n.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",n.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",n.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",n.NoClaimConditionSet="There is no claim condition set.",n.NoWallet="No wallet connected.",n.Unknown="No claim conditions found.",n}({});function Ye(n){if(n===void 0){const r=Buffer.alloc(16);return Me({},r),Z(de(r.toString("hex")))}else return Z(n)}const ue=S.object({to:X.refine(n=>n.toLowerCase()!==k,{message:"Cannot create payload to mint to zero address"}),price:z.default(0),currencyAddress:we.default(Q),mintStartTime:ne,mintEndTime:Ie,uid:S.string().optional().transform(n=>Ye(n)),primarySaleRecipient:X.default(k)}),Ze=ue.extend({quantity:z}),pt=Ze.extend({mintStartTime:P,mintEndTime:P}),Y=ue.extend({metadata:j,royaltyRecipient:S.string().default(k),royaltyBps:Se.default(0)}),le=Y.extend({metadata:j.default(""),uri:S.string(),royaltyBps:P,mintStartTime:P,mintEndTime:P}),Xe=Y.extend({metadata:j.default(""),quantity:$}),dt=Xe.extend({tokenId:$}),mt=le.extend({tokenId:P,quantity:P}),yt=Y.extend({metadata:j.default(""),quantity:P.default(1)}),gt=le.extend({quantity:P.default(1)}),bt=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],wt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],St=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],xt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];var _e=function n(r,e){if(r===e)return!0;if(r&&e&&typeof r=="object"&&typeof e=="object"){if(r.constructor!==e.constructor)return!1;var t,s,a;if(Array.isArray(r)){if(t=r.length,t!=e.length)return!1;for(s=t;s--!==0;)if(!n(r[s],e[s]))return!1;return!0}if(r.constructor===RegExp)return r.source===e.source&&r.flags===e.flags;if(r.valueOf!==Object.prototype.valueOf)return r.valueOf()===e.valueOf();if(r.toString!==Object.prototype.toString)return r.toString()===e.toString();if(a=Object.keys(r),t=a.length,t!==Object.keys(e).length)return!1;for(s=t;s--!==0;)if(!Object.prototype.hasOwnProperty.call(e,a[s]))return!1;for(s=t;s--!==0;){var o=a[s];if(!n(r[o],e[o]))return!1}return!0}return r!==r&&e!==e};const Tt=te(_e);export{ue as B,ht as C,St as M,dt as S,je as a,mt as b,H as c,Tt as d,nt as e,Fe as f,at as g,ut as h,V as i,yt as j,gt as k,it as l,wt as m,ot as n,xt as o,lt as p,Ze as q,pt as r,bt as s,ct as t,ft as u,Ye as v};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/index-OE56k1X-.js","assets/index-Zpn9ZsWz.css"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}